---
title: 深度强化学习概念
description: 
tags: [RL，DRL]
categories:
 - conception
comment_title: 强化学习
---





部分可观测马尔可夫决策过程（partially observable Markov decision process, POMDP）



基于价值的智能体（Value-based agent）显式的学习价值函数， 隐式地学习他的策略（由价值得来）

> Q-Learning、 Sarsa

基于策略的智能体（policy-based agent）直接学习策略，给一个状态，就会输出对应动作的概率。

> Policy Gradient

actor-critic agent：结合策略和价值



马尔可夫性质也可以描述为给定当前状态时，将来的状态与过去状态是条件独立的。如果某一个过程满足**马尔可夫性质**，那么未来的转移与过去的是独立的，它只取决于现在。马尔可夫性质是所有马尔可夫过程的基础。

使用折扣因子的原因如下。第一，有些马尔可夫过程是带环的，它并不会终结，我们想避免无穷的奖励。第二，我们并不能建立完美的模拟环境的模型，我们对未来的评估不一定是准确的，我们不一定完全信任模型，因为这种不确定性，所以我们对未来的评估增加一个折扣。我们想把这个不确定性表示出来，希望尽可能快地得到奖励，而不是在未来某一个点得到奖励。第三，如果奖励是有实际价值的，我们可能更希望立刻就得到奖励，而不是后面再得到奖励（现在的钱比以后的钱更有价值）。最后，我们也更想得到即时奖励。有些时候可以把折扣因子设为 0（γ=0），我们就只关注当前的奖励。我们也可以把折扣因子设为 1（γ=1），对未来的奖励并没有打折扣，未来获得的奖励与当前获得的奖励是一样的。折扣因子可以作为强化学习智能体的一个超参数（hyperparameter）来进行调整，通过调整折扣因子，我们可以得到不同动作的智能体。



贝尔曼方程：
$$
V(s) = R(s) + \gamma \sum_{s' \in S} p(s'|s)V(s')
$$
贝尔曼方程就是当前状态与未来状态的迭代关系，表示当前状态的价值函数可以通过下个状态的价值函数来计算。

> 贝尔曼方程因其提出者、动态规划创始人理查德 ⋅⋅ 贝尔曼（Richard Bellman）而得名 ，也叫作“动态规划方程”

蒙特卡洛方法就是当得到一个马尔可夫奖励过程后，我们可以从某个状态开始，把小船放到状态转移矩阵里面，让它“随波逐流”，这样就会产生一个轨迹。产生一个轨迹之后，就会得到一个奖励，那么直接把折扣的奖励即回报 g 算出来。算出来之后将它积累起来，得到回报Gt。 当积累了一定数量的轨迹之后，我们直接用 Gt 除以轨迹数量，就会得到某个状态的价值。



马尔可夫决策过程：未来的状态不仅依赖于当前的状态，也依赖于在当前状态智能体采取的动作



马尔可夫决策过程中的价值函数可定义为：
$$
V_\pi (s) = E_{\pi}[G_t|s_t = s]
$$
Q 函数定义的是在某一个状态采取某一个动作，它有可能得到的回报的一个期望:
$$
Q_\pi(s, a) = E_\pi[G_t|s_t = s, a_t = a]
$$

$$
V_\pi(s) = \sum_{a \in A} \pi (a | s)Q_\pi(s, a)
$$

对 Q 函数的贝尔曼方程进行推导：
$$
Q(s, a ) = R(s, a) + \gamma \sum_{s' \in S}p(s' |s, a)V(s')
$$


备份图:备份图定义了未来下一时刻的状态价值函数与上一时刻的状态价值函数之间的关联



策略评估：也被称为价值预测，也就是预测我们当前采取的策略**最终**会产生多少价值



预测与控制：

- 预测：输入是马尔可夫决策过程<$ S, A, P, R, \gamma$> 和 策略$\pi$ ,计算它的价值函数，也就是计算每个状态的价值

- 控制（搜索最佳策略）的输入是马尔可夫决策过程 $<S,A,P,R,γ>$，输出是最佳价值函数（optimal value function）$ V ^*$ 和最佳策略（optimal policy）$π^*$。控制就是我们去寻找一个最佳的策略，然后同时输出它的最佳价值函数以及最佳策略。



#### 表格型方法

概率函数和奖励函数：概率函数：状态转移的概率，实际上概率函数和奖励函数未知

Q表格：横轴表示动作，纵轴表示环境状态，可利用时序差分的方法进行更新

时序差分：$Q(s_t, a_t) = Q(s_t, a_t) + \alpha [r_{t+1} + \gamma Q(s_{t+1}, a_{t+1}) - Q(s_t, a_t)]$

Sarsa算法：同策略强化学习算法，由于需要知道$s_t, a_t, r_{t+1}, s_{t+1}, a_{t+1}$而命名，智能体每一次循环都会对前一步Q值进行一次更新



on-policy和off-policy的区别在于生成样本的策略和参数更新时的策略是否相同。



蒙特卡罗和时序差分方法是免模型，动态规划方法是有模型方法；时序差分方法和动态规划方法都能给予当前状态的下一步预测情况来对当前状态的价值函数进行更新

蒙特卡洛方法需要产生一整条马尔可夫链并直到最终结束才能进行更新。它是无偏估计，但是方差大



策略梯度：

技巧1:添加基线b
$$
b = E(R(\tau))
$$
修改原奖励函数为
$$
R(\tau^n) \rightarrow R(\tau ^ n - b)
$$
技巧2:分配合适的分数

给每一个动作分配合适的分数，因为即便最后得到的奖励很好，不代表每一个动作都很好，即便最后的结果很差，不代表每一个动作都很差

一个动作获得的奖励不会影响到之前的奖励，只会影响到以后的奖励，因此，一个动作的好坏归因于做完这个动作a后，之后获得的所有奖励，但是一个动作的影响随着回合增加影响会减少，因此对于后面的奖励应该乘以折扣因子：
$$
1 + \gamma \times3 + \gamma ^ 2 \times (-5)
$$
来代表当前动作的价值，那整个梯度应该变为：
$$
\nabla \bar{R_\theta} \approx \frac{1}{N} \sum_{n=1}^N\sum_{t=1}^{T_n}(\sum_{t'=t}^{T_n} \gamma ^ {t'-t}r_{t'}^n-b)\nabla logp_\theta(a^n_t|s^n_t)
$$
其实实现就是一个优势函数，$A^\theta(s+t, a_t)$ 代表在某个状态才去某个动作a的时候，优势函数的值，来作为他的权重，这个可以这个可以用一个网络来估计，也就是critic网络

#### 近端策略优化（PPO）On-policy算法

由于在做重要性采样的时候，$p_\theta(a_t|s_t)$不能与$p_{\theta^\prime}(a_t|s_t)$相差太多，相差太多，重要性采样的结果就会不好。在训练的时候，应多加一个约束（constrain）这个约束是$\theta,\theta^\prime$输出动作的KL散度，用于衡量$\theta,\theta^\prime$的相似程度。因此PPO里有两项，一个是优化本来的$J^{\theta^\prime}(\theta)$，另一个是约束项，它所做的就是希望最后学习出的$\theta,\theta^\prime$ 相差不大
$$
J_{PPO}^{\theta^\prime}(\theta) = J^{\theta^\prime}(\theta) - \beta KL(\theta, \theta^\prime)
$$

$$
J^{\theta^\prime}(\theta) = E_{(s_t, a_t)\sim\pi_{\theta^\prime}}[\frac{p_\theta(a_t|s_t)}{p_{\theta^\prime}(a_t|s_t)}A^{\theta^\prime}(s_t, a_t)]
$$

Q：为什么不直接计算$\theta, \theta^\prime$的距离，甚至只需要L1，L2Norm都不需要KL？

A：我们考虑输出的动作相似就行了，因为参数上发生微小变化可能也会导致动作的输出概率差别很大，所以不能只约束参数距离，或者说只约束参数距离是不够的。

#### 目标网络（Target net）

原本：
$$
Q_\pi(s_t, a_t) = r_t + Q_\pi(s_{t+1}, \pi(s_{t+1}))
$$
更新的时候，会把两次更新加在一起，因为我们拟合的目标$Q_\pi(s_{t+1}, \pi(s_{t+1}))$一直在变动，所以会导致不好训练。

于是在实际过程中，我们会把后者固定住，做法通常是左边多次更新后，去更新右边，也就是使用了一个target网络

#### 探索

方法有$\epsilon$-贪心和玻尔兹曼探索（Boltzmann exploration）

主要说说玻尔兹曼探索：对于任意的$s, a, Q(s,a)>= 0,a$被选中的概率与$e^{Q(s,a)/T}$呈正比
$$
\pi(a|s) = \frac{e^{Q(s,a)/T}}{\sum_{a^\prime\in A}e^{Q(s,a^\prime)/T}}
$$
其中$T>0$称为温度系数。

#### 经验回放（experience replay）

使用经验回放会使一个算法变为异策略（off- policy）

#### 双深度Q网络（double DQN， DDQN）

#### 竞争深度Q网络

#### 优先级经验回放（prioritized experience replay, PER）

> 假设有一些数据，我们之前采样过，发现这些数据的时序差分误差特别大（时序差分误差就是网络的输出与目标之间的差距），这代表我们在训练网络的时候，这些数据是比较不好训练的。既然比较不好训练，就应该给它们比较大的概率被采样到，即给它**优先权（priority）**

#### 噪声网络

> 它是在参数的空间上加噪声。噪声网络是指，每一次在一个回合开始的时候，在智能体要与环境交互的时候，智能体使用Q函数来采取动作，Q函数里面就是一个网络，我们在网络的每一个参数上加上一个高斯噪声， 就把原来的Q函数变成$\tilde{Q}$

这里要注意，在每个回合开始的时候，与环境交互之前，我们就采样噪声。接下来我们用固定的噪声网络玩游戏，直到游戏结束，才重新采样新的噪声，噪声在一个回合中是不能被改变的。

#### 分布式Q函数

#### 彩虹（rainbow）

我们把全部方法都用上就变成了七彩的方法，即彩虹方法，彩虹方法的性能很好。

#### 路径衍生策略梯度

评论员会直接告诉演员做什么样的动作才可以得到比较大的值。



### 模仿学习

#### 行为克隆

失之毫厘，差之千里

#### 逆强化学习

有了环境和专家的示范以后，可以反推出奖励函数。强化学习是由奖励函数反推出什么样的动作、演员是最好的。逆强化学习则反过来，我们有专家的示范，我们相信它是不错的，我就反推，专家是因为什么样的奖励函数才会采取这些行为。有了奖励函数以后，接下来，我们就可以使用一般的强化学习的方法去找出最优演员。所以逆强化学习是先找出奖励函数，找出奖励函数以后，再用强化学习找出最优演员。

最终的奖励函数无法分辨出谁应该会得到比较高的分数

#### 第三人称视角模仿学习

### 深度确定性策略梯度（DDPG）